"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.assertValidVerifiablePresentations = exports.putPresentationSubmissionInLocation = exports.createPresentationSubmission = exports.extractPresentationsFromAuthorizationResponse = exports.verifyPresentations = void 0;
const pex_1 = require("@sphereon/pex");
const ssi_types_1 = require("@sphereon/ssi-types");
const helpers_1 = require("../helpers");
const types_1 = require("../types");
const PresentationExchange_1 = require("./PresentationExchange");
const types_2 = require("./types");
const verifyPresentations = (authorizationResponse, verifyOpts) => __awaiter(void 0, void 0, void 0, function* () {
    var _a, _b, _c;
    const presentations = yield (0, exports.extractPresentationsFromAuthorizationResponse)(authorizationResponse);
    const presentationDefinitions = verifyOpts.presentationDefinitions
        ? Array.isArray(verifyOpts.presentationDefinitions)
            ? verifyOpts.presentationDefinitions
            : [verifyOpts.presentationDefinitions]
        : [];
    let idPayload;
    if (authorizationResponse.idToken) {
        idPayload = yield authorizationResponse.idToken.payload();
    }
    // todo: Probably wise to check against request for the location of the submission_data
    const presentationSubmission = authorizationResponse.payload.presentation_submission
        ? authorizationResponse.payload.presentation_submission
        : (_a = idPayload === null || idPayload === void 0 ? void 0 : idPayload._vp_token) === null || _a === void 0 ? void 0 : _a.presentation_submission;
    yield (0, exports.assertValidVerifiablePresentations)({
        presentationDefinitions,
        presentations,
        verificationCallback: verifyOpts.verification.presentationVerificationCallback,
        opts: {
            presentationSubmission,
            restrictToFormats: verifyOpts.restrictToFormats,
            restrictToDIDMethods: verifyOpts.restrictToDIDMethods,
        },
    });
    const revocationVerification = ((_b = verifyOpts.verification) === null || _b === void 0 ? void 0 : _b.revocationOpts)
        ? verifyOpts.verification.revocationOpts.revocationVerification
        : types_1.RevocationVerification.IF_PRESENT;
    if (revocationVerification !== types_1.RevocationVerification.NEVER) {
        if (!((_c = verifyOpts.verification.revocationOpts) === null || _c === void 0 ? void 0 : _c.revocationVerificationCallback)) {
            throw Error(`Please provide a revocation callback as revocation checking of credentials and presentations is not disabled`);
        }
        for (const vp of presentations) {
            yield (0, helpers_1.verifyRevocation)(vp, verifyOpts.verification.revocationOpts.revocationVerificationCallback, revocationVerification);
        }
    }
    return { presentations, presentationDefinitions, submissionData: presentationSubmission };
});
exports.verifyPresentations = verifyPresentations;
const extractPresentationsFromAuthorizationResponse = (response) => __awaiter(void 0, void 0, void 0, function* () {
    const wrappedVerifiablePresentations = [];
    if (response.payload.vp_token) {
        const presentations = Array.isArray(response.payload.vp_token) ? response.payload.vp_token : [response.payload.vp_token];
        for (const presentation of presentations) {
            wrappedVerifiablePresentations.push(ssi_types_1.CredentialMapper.toWrappedVerifiablePresentation(presentation));
        }
    }
    return wrappedVerifiablePresentations;
});
exports.extractPresentationsFromAuthorizationResponse = extractPresentationsFromAuthorizationResponse;
const createPresentationSubmission = (verifiablePresentations, opts) => __awaiter(void 0, void 0, void 0, function* () {
    let submission_data;
    for (const verifiablePresentation of verifiablePresentations) {
        const wrappedPresentation = ssi_types_1.CredentialMapper.toWrappedVerifiablePresentation(verifiablePresentation);
        let submission = wrappedPresentation.presentation.presentation_submission ||
            wrappedPresentation.decoded.presentation_submission ||
            (typeof wrappedPresentation.original !== 'string' && wrappedPresentation.original.presentation_submission);
        if (!submission && (opts === null || opts === void 0 ? void 0 : opts.presentationDefinitions)) {
            console.log(`No submission_data in VPs and not provided. Will try to deduce, but it is better to create the submission data beforehand`);
            for (const definitionOpt of opts.presentationDefinitions) {
                const definition = 'definition' in definitionOpt ? definitionOpt.definition : definitionOpt;
                const result = new pex_1.PEX().evaluatePresentation(definition, wrappedPresentation.original, { generatePresentationSubmission: true });
                if (result.areRequiredCredentialsPresent) {
                    submission = result.value;
                    break;
                }
            }
        }
        if (!submission) {
            throw Error('Verifiable Presentation has no submission_data, it has not been provided separately, and could also not be deduced');
        }
        // let's merge all submission data into one object
        if (!submission_data) {
            submission_data = submission;
        }
        else {
            // We are pushing multiple descriptors into one submission_data, as it seems this is something which is assumed in OpenID4VP, but not supported in Presentation Exchange (a single VP always has a single submission_data)
            Array.isArray(submission_data.descriptor_map)
                ? submission_data.descriptor_map.push(...submission.descriptor_map)
                : (submission_data.descriptor_map = [...submission.descriptor_map]);
        }
    }
    return submission_data;
});
exports.createPresentationSubmission = createPresentationSubmission;
const putPresentationSubmissionInLocation = (authorizationRequest, responsePayload, resOpts, idTokenPayload) => __awaiter(void 0, void 0, void 0, function* () {
    var _d, _e, _f, _g, _h, _j;
    const version = yield authorizationRequest.getSupportedVersion();
    const idTokenType = yield authorizationRequest.containsResponseType(types_1.ResponseType.ID_TOKEN);
    const authResponseType = yield authorizationRequest.containsResponseType(types_1.ResponseType.VP_TOKEN);
    // const requestPayload = await authorizationRequest.mergedPayloads();
    if (!resOpts.presentationExchange) {
        return;
    }
    else if (resOpts.presentationExchange.verifiablePresentations.length === 0) {
        throw Error('Presentation Exchange options set, but no verifiable presentations provided');
    }
    if (!resOpts.presentationExchange.presentationSubmission &&
        (!resOpts.presentationExchange.verifiablePresentations || resOpts.presentationExchange.verifiablePresentations.length === 0)) {
        throw Error(`Either a presentationSubmission or verifiable presentations are needed at this point`);
    }
    const submissionData = (_d = resOpts.presentationExchange.presentationSubmission) !== null && _d !== void 0 ? _d : (yield (0, exports.createPresentationSubmission)(resOpts.presentationExchange.verifiablePresentations, {
        presentationDefinitions: yield authorizationRequest.getPresentationDefinitions(),
    }));
    const location = (_f = (_e = resOpts.presentationExchange) === null || _e === void 0 ? void 0 : _e.vpTokenLocation) !== null && _f !== void 0 ? _f : (idTokenType ? types_2.VPTokenLocation.ID_TOKEN : types_2.VPTokenLocation.AUTHORIZATION_RESPONSE);
    switch (location) {
        case types_2.VPTokenLocation.TOKEN_RESPONSE: {
            throw Error('Token response for VP token is not supported yet');
        }
        case types_2.VPTokenLocation.ID_TOKEN: {
            if (!idTokenPayload) {
                throw Error('Cannot place submission data _vp_token in id token if no id token is present');
            }
            else if (version >= types_1.SupportedVersion.SIOPv2_D11) {
                throw Error(`This version of the OpenID4VP spec does not allow to store the vp submission data in the ID token`);
            }
            else if (!idTokenType) {
                throw Error(`Cannot place vp token in ID token as the RP didn't provide an "openid" scope in the request`);
            }
            if ((_g = idTokenPayload._vp_token) === null || _g === void 0 ? void 0 : _g.presentation_submission) {
                if (submissionData !== idTokenPayload._vp_token.presentation_submission) {
                    throw Error('Different submission data was provided as an option, but exising submission data was already present in the id token');
                }
            }
            else {
                if (!idTokenPayload._vp_token) {
                    idTokenPayload._vp_token = { presentation_submission: submissionData };
                }
                else {
                    idTokenPayload._vp_token.presentation_submission = submissionData;
                }
            }
            break;
        }
        case types_2.VPTokenLocation.AUTHORIZATION_RESPONSE: {
            if (!authResponseType) {
                throw Error('Cannot place vp token in Authorization Response as there is no vp_token scope in the auth request');
            }
            if (responsePayload.presentation_submission) {
                if (submissionData !== responsePayload.presentation_submission) {
                    throw Error('Different submission data was provided as an option, but exising submission data was already present in the authorization response');
                }
            }
            else {
                responsePayload.presentation_submission = submissionData;
            }
        }
    }
    const vps = ((_j = (_h = resOpts.presentationExchange) === null || _h === void 0 ? void 0 : _h.verifiablePresentations) === null || _j === void 0 ? void 0 : _j.map((vp) => ssi_types_1.CredentialMapper.toWrappedVerifiablePresentation(vp).original)) || [];
    responsePayload.vp_token = vps.length === 1 ? vps[0] : vps;
});
exports.putPresentationSubmissionInLocation = putPresentationSubmissionInLocation;
const assertValidVerifiablePresentations = (args) => __awaiter(void 0, void 0, void 0, function* () {
    if ((!args.presentationDefinitions || args.presentationDefinitions.filter((a) => a.definition).length === 0) &&
        (!args.presentations || (Array.isArray(args.presentations) && args.presentations.filter((vp) => vp.presentation).length === 0))) {
        return;
    }
    PresentationExchange_1.PresentationExchange.assertValidPresentationDefinitionWithLocations(args.presentationDefinitions);
    const presentationsWithFormat = args.presentations;
    if (args.presentationDefinitions && args.presentationDefinitions.length && (!presentationsWithFormat || presentationsWithFormat.length === 0)) {
        throw new Error(types_1.SIOPErrors.AUTH_REQUEST_EXPECTS_VP);
    }
    else if ((!args.presentationDefinitions || args.presentationDefinitions.length === 0) &&
        presentationsWithFormat &&
        presentationsWithFormat.length > 0) {
        throw new Error(types_1.SIOPErrors.AUTH_REQUEST_DOESNT_EXPECT_VP);
    }
    else if (args.presentationDefinitions && presentationsWithFormat && args.presentationDefinitions.length != presentationsWithFormat.length) {
        throw new Error(types_1.SIOPErrors.AUTH_REQUEST_EXPECTS_VP);
    }
    else if (args.presentationDefinitions && !args.opts.presentationSubmission) {
        throw new Error(`No presentation submission present. Please use presentationSubmission opt argument!`);
    }
    else if (args.presentationDefinitions && presentationsWithFormat) {
        yield PresentationExchange_1.PresentationExchange.validatePresentationsAgainstDefinitions(args.presentationDefinitions, presentationsWithFormat, args.verificationCallback, args.opts);
    }
});
exports.assertValidVerifiablePresentations = assertValidVerifiablePresentations;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiT3BlbklENFZQLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL2F1dGhvcml6YXRpb24tcmVzcG9uc2UvT3BlbklENFZQLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUFBLHVDQUE2RDtBQUU3RCxtREFBeUk7QUFHekksd0NBQThDO0FBQzlDLG9DQVFrQjtBQUdsQixpRUFBOEQ7QUFDOUQsbUNBTWlCO0FBRVYsTUFBTSxtQkFBbUIsR0FBRyxDQUNqQyxxQkFBNEMsRUFDNUMsVUFBMkMsRUFDTCxFQUFFOztJQUN4QyxNQUFNLGFBQWEsR0FBRyxNQUFNLElBQUEscURBQTZDLEVBQUMscUJBQXFCLENBQUMsQ0FBQztJQUNqRyxNQUFNLHVCQUF1QixHQUFHLFVBQVUsQ0FBQyx1QkFBdUI7UUFDaEUsQ0FBQyxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsVUFBVSxDQUFDLHVCQUF1QixDQUFDO1lBQ2pELENBQUMsQ0FBQyxVQUFVLENBQUMsdUJBQXVCO1lBQ3BDLENBQUMsQ0FBQyxDQUFDLFVBQVUsQ0FBQyx1QkFBdUIsQ0FBQztRQUN4QyxDQUFDLENBQUMsRUFBRSxDQUFDO0lBQ1AsSUFBSSxTQUFxQyxDQUFDO0lBQzFDLElBQUkscUJBQXFCLENBQUMsT0FBTyxFQUFFO1FBQ2pDLFNBQVMsR0FBRyxNQUFNLHFCQUFxQixDQUFDLE9BQU8sQ0FBQyxPQUFPLEVBQUUsQ0FBQztLQUMzRDtJQUNELHVGQUF1RjtJQUN2RixNQUFNLHNCQUFzQixHQUFHLHFCQUFxQixDQUFDLE9BQU8sQ0FBQyx1QkFBdUI7UUFDbEYsQ0FBQyxDQUFDLHFCQUFxQixDQUFDLE9BQU8sQ0FBQyx1QkFBdUI7UUFDdkQsQ0FBQyxDQUFDLE1BQUEsU0FBUyxhQUFULFNBQVMsdUJBQVQsU0FBUyxDQUFFLFNBQVMsMENBQUUsdUJBQXVCLENBQUM7SUFDbEQsTUFBTSxJQUFBLDBDQUFrQyxFQUFDO1FBQ3ZDLHVCQUF1QjtRQUN2QixhQUFhO1FBQ2Is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